main:
  best_move();
end main;

on_move:
  if(current_player == 0) then
    best_move();
  else
    move_a();
  end if;
end on_move;

move_a():
  let objective = [0, height - 1];
  let best_dest = [width - 1, 0];
  let alt_best_dest = [width - 1, 0];
  let best_piece = [width - 1, 0];
  let alt_best_piece = [width - 1, 0];
  for x from 0 to width - 1 do
    for y from 0 to height - 1 do
      if(board[x, y].owner == 1) then
        let dest = get_best_dest([x, y], objective);
        let alt_dest = get_alt_dest([x, y], objective);
        if(dist(dest, objective) < dist(best_dest, objective)) then
          best_dest = dest;
          best_piece = [x, y];
        end if;
        if(dist(alt_dest, objective) < dist(alt_best_dest, objective)) then
          alt_best_dest = alt_dest;
          alt_best_piece = [x, y];
        end if;
      end if;
    done;
  done;
  if(best_piece /= best_dest) then
    print(best_piece + " -> " + best_dest);
    move(best_piece, best_dest);
  else
    print(alt_best_dest + " -> " + alt_best_dest);
    move(alt_best_dest, alt_best_dest);  
  end if;

end move_a;

point get_best_dest(origin : point, objective : point):
  let best_dest = [width - 1, 0];
  for x from -2 to 2 do
    for y from -2 to 2 do
      if(can_move(origin, origin + [x, y])) then
        if(dist(origin + [x, y], objective) < dist(best_dest, objective)) then
          if(dist(origin + [x, y], objective) < dist(origin, objective)) then
            best_dest = origin + [x, y];
          end if;
        end if;
      end if;
    done;
  done;
  return best_dest;
end get_best_dest;

point get_alt_dest(origin : point, objective : point):
  let best_dest = [width - 1, 0];
  for x from -2 to 2 do
    for y from -2 to 2 do
      if(can_move(origin, origin + [x, y])) then
        if(dist(origin + [x, y], objective) <= dist(best_dest, objective)) then
          if(dist(origin + [x, y], objective) <= dist(origin, objective)) then
            best_dest = origin + [x, y];
          end if;
        end if;
      end if;
    done;
  done;
  return best_dest;
end get_alt_dest;


int dist(a : point, b : point):
  return abs(a[0] - b[0]) + abs(a[1] - b[1]);
end dist;

int abs(num : int):
  if(num > 0) then
    return num;
  else
    return 0 - num;
  end if;
end abs;

best_move():
  let p1 = [0,0];
  let p2 = [0,0];
  let furthest = 0;
  for i from 0 to width - 1 do
    for j from 0 to height - 1 do
      if(board[i, j].owner == 0) then
        let dest = get_furthest_jump([i,j]);
        if(norm(dest) > norm(p2)) then
            p1 = [i, j];
            p2 = dest;
        end if;
      end if;
    done;
  done;
  print(p2);
  print(p2 == [0, 0]);
  if p2 == [0, 0] then
    p2 = [width - 1, height - 1];
    for i from 0 to width - 1 do
      for j from 0 to height - 1 do
        if(board[i, j].owner == 0) then
          let dest = get_possible_jump([i,j]);
          if(norm(dest) > norm(p2)) then
            p1 = [i, j];
            p2 = dest;
          end if;
        end if;
      done;
    done;
  end if;
  if p1 /= p2 then 
    move(p1, p1 + p2); 
  end if; 
end best_move;

point get_furthest_jump(piece : point):
  let res = [0, 0];
  for i from 0 to 2 do
    for j from -2 to 0 do 
      if can_move(piece, piece + [i, j]) then
        if norm([i, j]) > norm(res) then
          res = [i, j];
        end if;
      end if;
    done;
  done;
  return res;
end get_furthest_jump;

point get_possible_jump(piece : point):
  let res = [-2, 2];
  for i from -2 to 0 do
    for j from 0 to 2 do 
      print(piece + "->" + (piece + [i, j]));
      print(can_move(piece, piece + [i, j]));
      if can_move(piece, piece + [i, j]) then
        if norm([i, j]) < norm(res) then
          res = [i, j];
        end if;
      end if;
    done;
  done;
  print(res);
  return res;
end get_possible_jump;

int norm(in : point):
  return in[0]^2 + in[1]^2;
end norm;

