/*
  globally defined vars:
  current_player = {0, 1} //current player, either 0 or 1
  width, height
  board[x, y] //set of pieces in board
  board[x, y] == {
    piece_name: ,
    owner: 
  }
  can_move([x_prev, y_prev], [x_next, y_next]) // returns 1 or 0
  move([x_prev, y_prev], [x_next, y_next]) // returns 1 or 0 (success or failure)

  Types (todos os tipos são deduzidos da declaraçao let):
    int     -> 1 (tambem serve para condicionais, tipo C)
    string  -> 'asd' | "asd"
    point   -> [1, 3]
  All types can be null

  Operations:
    int op int -> + - * / %
    int op string -> + (concat) * (mult, "a" * 3 == "aaa") comutativa 
    int op point -> + - * / % (operaçao ponto a ponto, a op [b, c] = [a op b, b op c], comutativa)
    string op string -> + (concat)
    point op point -> [a, b] op [x, y] == [a op x, b op y]
  
*/



move_forward(int i, int j):
  move([i, j + 1]);
end move_forward;

int can_move_forward(int i, int j):
  return can_move([i, j + 1]);
end move_forward;

point first_available_move(int dir):
  for x from 0 to width do
    for y from 0 to height do
      if can_move([x, y], [x, y] + dir) then
        return [x, y];
      endif;
    done;
  done;
  return null;
end first_available_move;

main:
  let i : int = 0;
  let j = i + 2 * 3 / 2 % 2;
  let name : string = null;
  if j == 2 then
    move([1, 2], [3, 4]);
  endif;

  for i from 0 to 10 do
    move([i, i - 1], [1, 2]);
  done;
end main;