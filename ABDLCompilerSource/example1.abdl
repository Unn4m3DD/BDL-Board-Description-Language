/*
  globally defined vars:
  current_player = {0, 1} //current player, either 0 or 1
  width, height
  board[x, y] //set of pieces in board
  board[x, y] == {
    piece_name: ,
    owner: 
  }
  can_move([x_prev, y_prev], [x_next, y_next]) // returns 1 or 0
  move([x_prev, y_prev], [x_next, y_next]) // returns 1 or 0 (success or failure)

  Types (todos os tipos são deduzidos da declaraçao let):
    int     -> 1 (tambem serve para condicionais, tipo C)
    string  -> 'asd' | "asd"
    point   -> [1, 3]
  All types can be null

  Operations:
    int op int -> + - * / %
    int op string -> + (concat) * (mult, "a" * 3 == "aaa") comutativa 
    int op point -> + - * / % (operaçao ponto a ponto, a op [b, c] = [a op b, b op c], comutativa)
    string op string -> + (concat)
    point op point -> [a, b] op [x, y] == [a op x, b op y]
  

  Extensive:
  int + int       ->  int
  int + string    ->  string
  int + point     ->  point
  string + int    ->  string
  string + string ->  string
  string + point  ->  string
  point + int     ->  point
  point + string  ->  string
  point + point   ->  point
  
  int - int       ->  int
  int - string    ->  undefined
  int - point     ->  point
  string - int    ->  undefined
  string - string ->  undefined
  string - point  ->  undefined
  point - int     ->  point
  point - string  ->  undefined
  point - point   ->  point

  int * int       ->  int
  int * string    ->  string
  int * point     ->  point
  string * int    ->  string
  string * string ->  undefined
  string * point  ->  undefined
  point * int     ->  point
  point * string  ->  undefined
  point * point   ->  point
  
  int / int       ->  int
  int / string    ->  undefined
  int / point     ->  point
  string / int    ->  undefined
  string / string ->  undefined
  string / point  ->  undefined
  point / int     ->  point
  point / string  ->  undefined
  point / point   ->  point
  
  int % int       ->  int
  int % string    ->  undefined
  int % point     ->  point
  string % int    ->  undefined
  string % string ->  undefined
  string % point  ->  undefined
  point % int     ->  point
  point % string  ->  undefined
  point % point   ->  point
  
  int (== | !=) int       ->  int
  int (== | !=) string    ->  undefined
  int (== | !=) point     ->  undefined
  string (== | !=) int    ->  undefined
  string (== | !=) string ->  int
  string (== | !=) point  ->  undefined
  point (== | !=) int     ->  undefined
  point (== | !=) string  ->  undefined
  point (== | !=) point   ->  int
  
  int (< | <= | > | >=) int       ->  int
  int (< | <= | > | >=) string    ->  undefined
  int (< | <= | > | >=) point     ->  undefined
  string (< | <= | > | >=) int    ->  undefined
  string (< | <= | > | >=) string ->  undefined
  string (< | <= | > | >=) point  ->  undefined
  point (< | <= | > | >=) int     ->  undefined
  point (< | <= | > | >=) string  ->  undefined
  point (< | <= | > | >=) point   ->  undefined
  
  
*/



move_forward(i : int, j : int):
  move([i, j + 1]);
end move_forward;

int can_move_forward(i : int, j : int):
  return can_move([i, j + 1]);
end move_forward;

point first_available_move(dir : point):
  for x from 0 to width do
    for y from 0 to height do
      if can_move([x, y], [x, y] + dir) then
        return [x, y];
      endif;
    done;
  done;
  return null;
end first_available_move;

main:
  let i : int = 0;
  let j = i + 2 * 3 / 2 % 2;
  let name : string = null;
  if j == 2 then
    move([1, 2], [3, 4]);
  endif;

  if board[1, 2].owner == 1 then
    move([1, 1], [1, 2]);
  else if board[2, 2].owner == 1 then
    move([2, 1], [2, 2]);
  endif;

  for i from 0 to width do
    if board[i, 2].owner == 1 then
      if(current_player == 0) then
        move([i, 1], [i, 2]);
      endif;
    endif;
  done;

  for i from 0 to 10 do
    move([i, i - 1], [1, 2]);
  done;

  while i < 2 do
    print(done);
  done;
end main;